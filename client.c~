#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <string.h>

#include "duckchat.h"
#include "raw.h"

#define true 1
#define false 0
#define BUFSIZE 1024

// :: Global Variables :: //
int sockfd= 0;
struct addrinfo *servinfo= NULL;
struct sockaddr_in *servaddr= NULL;
char msgBuf[BUFSIZE];


// :: Function Prototypes :: //
int msg_exit();
int msg_join(char*);
int msg_leave(char*);
int msg_list();
int msg_login(char*);
int msg_switch(char*);
int msg_who(char*);
char *new_inputString();
int parseInput(char*);
int sendMessage(struct request*, int);
int setupSocket(char*, char*);


int main(int argc, char** argv) {
	// Basic Argument Check
	if (argc != (3+1)) {
		printf("usage: ./client server_socket server_port username\n");
		return 1;
	}

	// Set the terminal to raw mode
	//raw_mode();

	if (setupSocket(argv[1], argv[2]) != true) {
		//cooked_mode();
		return 1;
	}

	if (msg_login(argv[3]) != true) {
		//cooked_mode();
		return 1;
	}

	int parseStatus= true;
	do {
		char *input= new_inputString();
		parseStatus= parseInput(input);
		free(input);
	} while (parseStatus != -1);

	freeaddrinfo(servinfo);

	//cooked_mode();
	return 0;
}

int msg_exit() {
	struct request_logout *req= (struct request_logout*) malloc(sizeof(struct request_logout));
	req->req_type= htonl(REQ_LOGOUT);
	sendMessage((struct request*)req, sizeof(struct request_logout));i
	
	free(req);
	return -1;
}

int msg_join(char *channel) {
	struct request_join *req= (struct request_join*) malloc(sizeof(struct request_join));
	req->req_type= htonl(REQ_JOIN);
	strncpy(req->req_channel, channel, CHANNEL_MAX - 1);
	req->req_channel[CHANNEL_MAX]= '\0';
	
	int result= sendMessage( (struct request*) req, sizeof(struct request_join));
	free(req);
	return result;
}

int msg_leave(char *channel) {
	return false;
}

int msg_list() {
	return false;
}

int msg_login(char *name) {
	struct request_login *req= (struct request_login*) malloc(sizeof(struct request_login));
	req->req_type= htonl(REQ_LOGIN);
	strncpy(req->req_username, name, USERNAME_MAX - 1);

	int result= sendMessage( (struct request*) req, sizeof(struct request_login));
	free(req);
	return result;
}

int msg_switch(char *channel) {
	return false;
}

int msg_who(char *channel) {
	return false;
}

char *new_inputString() {
	char *line= (char*) malloc(BUFSIZE*sizeof(char));
	size_t size= BUFSIZE;
	int numbits= getline(&line, &size, stdin);
	line[numbits]= '\0';

	return line;
}

int parseInput(char *input) {
	char *command= strtok(input, " ");
	if (command == NULL) {
		printf("You shouldn't see this shit");
		return -1;
	}
	
	// Remove trailing newline
	char *newline= strchr(command, '\n');
	*newline= '\0';

	if (0 == strcmp(command, "/exit")) {
		return msg_exit();
	} else if (0 == strcmp(command, "/join")) {
		char *channel= strtok(input, " ");
		return msg_join(channel);
	} else if (0 == strcmp(command, "/leave")) {
		char *channel= strtok(input, " ");
		return msg_leave(channel);
	} else if (0 == strcmp(command, "/list")) {
		
	} else if (0 == strcmp(command, "/who")) {

	} else if (0 == strcmp(command, "/switch")) {

	} else {

	}
	return false;
}

int sendMessage(struct request *req, int len) {
	int result= sendto(sockfd, req, len, 0, servinfo->ai_addr, servinfo->ai_addrlen);
	if (result == -1) {
		return false;
	}
	return true;
}

int setupSocket(char *addr, char *port) {
	int result= 0;

	// Setup hints
	struct addrinfo hints;
	memset(&hints, 0, sizeof hints);
	hints.ai_socktype= SOCK_DGRAM;

	// Fetch address info struct
	if ((result= getaddrinfo(addr, port, &hints, &servinfo)) != 0) {
		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
		return false;
	}

	// Create UDP socket
	sockfd= socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
	if (sockfd == -1) {
		perror("socket: ");
		return false;
	}

	return true;
}
